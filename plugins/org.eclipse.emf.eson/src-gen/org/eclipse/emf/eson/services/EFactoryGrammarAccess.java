/*
* generated by Xtext
*/
package org.eclipse.emf.eson.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class EFactoryGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class FactoryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Factory");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cImportsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cImportsNamespaceImportParserRuleCall_0_0 = (RuleCall)cImportsAssignment_0.eContents().get(0);
		private final Assignment cEpackagesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEpackagesPackageImportParserRuleCall_1_0 = (RuleCall)cEpackagesAssignment_1.eContents().get(0);
		private final Assignment cAnnotationsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAnnotationsAnnotationParserRuleCall_2_0 = (RuleCall)cAnnotationsAssignment_2.eContents().get(0);
		private final Assignment cRootAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRootNewObjectParserRuleCall_3_0 = (RuleCall)cRootAssignment_3.eContents().get(0);
		
		//Factory:
		//	imports+=NamespaceImport* epackages+=PackageImport* annotations+=Annotation* root=NewObject;
		public ParserRule getRule() { return rule; }

		//imports+=NamespaceImport* epackages+=PackageImport* annotations+=Annotation* root=NewObject
		public Group getGroup() { return cGroup; }

		//imports+=NamespaceImport*
		public Assignment getImportsAssignment_0() { return cImportsAssignment_0; }

		//NamespaceImport
		public RuleCall getImportsNamespaceImportParserRuleCall_0_0() { return cImportsNamespaceImportParserRuleCall_0_0; }

		//epackages+=PackageImport*
		public Assignment getEpackagesAssignment_1() { return cEpackagesAssignment_1; }

		//PackageImport
		public RuleCall getEpackagesPackageImportParserRuleCall_1_0() { return cEpackagesPackageImportParserRuleCall_1_0; }

		//annotations+=Annotation*
		public Assignment getAnnotationsAssignment_2() { return cAnnotationsAssignment_2; }

		//Annotation
		public RuleCall getAnnotationsAnnotationParserRuleCall_2_0() { return cAnnotationsAnnotationParserRuleCall_2_0; }

		//root=NewObject
		public Assignment getRootAssignment_3() { return cRootAssignment_3; }

		//NewObject
		public RuleCall getRootNewObjectParserRuleCall_3_0() { return cRootNewObjectParserRuleCall_3_0; }
	}

	public class PackageImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PackageImport");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cUseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cEPackageAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cEPackageEPackageCrossReference_1_0 = (CrossReference)cEPackageAssignment_1.eContents().get(0);
		private final RuleCall cEPackageEPackageQualifiedNameParserRuleCall_1_0_1 = (RuleCall)cEPackageEPackageCrossReference_1_0.eContents().get(1);
		private final Keyword cFullStopAsteriskKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//PackageImport: // TODO Validation rule with "deprecated" warning for 'use', now that we have 'import' instead 
		//	"use" ePackage=[ecore::EPackage|QualifiedName] ".*";
		public ParserRule getRule() { return rule; }

		//// TODO Validation rule with "deprecated" warning for 'use', now that we have 'import' instead 
		//"use" ePackage=[ecore::EPackage|QualifiedName] ".*"
		public Group getGroup() { return cGroup; }

		//// TODO Validation rule with "deprecated" warning for 'use', now that we have 'import' instead 
		//"use"
		public Keyword getUseKeyword_0() { return cUseKeyword_0; }

		//ePackage=[ecore::EPackage|QualifiedName]
		public Assignment getEPackageAssignment_1() { return cEPackageAssignment_1; }

		//[ecore::EPackage|QualifiedName]
		public CrossReference getEPackageEPackageCrossReference_1_0() { return cEPackageEPackageCrossReference_1_0; }

		//QualifiedName
		public RuleCall getEPackageEPackageQualifiedNameParserRuleCall_1_0_1() { return cEPackageEPackageQualifiedNameParserRuleCall_1_0_1; }

		//".*"
		public Keyword getFullStopAsteriskKeyword_2() { return cFullStopAsteriskKeyword_2; }
	}

	public class NamespaceImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NamespaceImport");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cImportedNamespaceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0 = (RuleCall)cImportedNamespaceAssignment_1.eContents().get(0);
		
		//// TODO like the *.Xtext grammar itself does, support namespace and package name based (try the 'import' above!) + maybe support an "as" syntax
		//// TODO Content Assist for EPackage .. but one COULD also import other named NewObject / EObject, instead of EPackages.. hm. As EPackage will be much more common, just support that.	
		//NamespaceImport:
		//	"import" importedNamespace=QualifiedNameWithWildcard;
		public ParserRule getRule() { return rule; }

		//"import" importedNamespace=QualifiedNameWithWildcard
		public Group getGroup() { return cGroup; }

		//"import"
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }

		//importedNamespace=QualifiedNameWithWildcard
		public Assignment getImportedNamespaceAssignment_1() { return cImportedNamespaceAssignment_1; }

		//QualifiedNameWithWildcard
		public RuleCall getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0() { return cImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0; }
	}

	public class AnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Annotation");
		private final RuleCall cCustomNameMappingParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Annotation:
		//	CustomNameMapping;
		public ParserRule getRule() { return rule; }

		//CustomNameMapping
		public RuleCall getCustomNameMappingParserRuleCall() { return cCustomNameMappingParserRuleCall; }
	}

	public class CustomNameMappingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CustomNameMapping");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNameKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cEClassAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cEClassEClassCrossReference_2_0 = (CrossReference)cEClassAssignment_2.eContents().get(0);
		private final RuleCall cEClassEClassQualifiedNameParserRuleCall_2_0_1 = (RuleCall)cEClassEClassCrossReference_2_0.eContents().get(1);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cNameFeatureAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final CrossReference cNameFeatureEAttributeCrossReference_4_0 = (CrossReference)cNameFeatureAssignment_4.eContents().get(0);
		private final RuleCall cNameFeatureEAttributeQualifiedNameParserRuleCall_4_0_1 = (RuleCall)cNameFeatureEAttributeCrossReference_4_0.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//// TODO further consider if name mapping is best put in-line into objects.. it would have to repeat in every file..
		//// logically this rather belongs into an external mapping, like HUTN's Configuration (HutnConfig), or even better directly into an Xcore as annotations 
		//CustomNameMapping:
		//	"@Name" "{" eClass=[ecore::EClass|QualifiedName] "=" nameFeature=[ecore::EAttribute|QualifiedName] "}";
		public ParserRule getRule() { return rule; }

		//"@Name" "{" eClass=[ecore::EClass|QualifiedName] "=" nameFeature=[ecore::EAttribute|QualifiedName] "}"
		public Group getGroup() { return cGroup; }

		//"@Name"
		public Keyword getNameKeyword_0() { return cNameKeyword_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//eClass=[ecore::EClass|QualifiedName]
		public Assignment getEClassAssignment_2() { return cEClassAssignment_2; }

		//[ecore::EClass|QualifiedName]
		public CrossReference getEClassEClassCrossReference_2_0() { return cEClassEClassCrossReference_2_0; }

		//QualifiedName
		public RuleCall getEClassEClassQualifiedNameParserRuleCall_2_0_1() { return cEClassEClassQualifiedNameParserRuleCall_2_0_1; }

		//"="
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }

		//nameFeature=[ecore::EAttribute|QualifiedName]
		public Assignment getNameFeatureAssignment_4() { return cNameFeatureAssignment_4; }

		//[ecore::EAttribute|QualifiedName]
		public CrossReference getNameFeatureEAttributeCrossReference_4_0() { return cNameFeatureEAttributeCrossReference_4_0; }

		//QualifiedName
		public RuleCall getNameFeatureEAttributeQualifiedNameParserRuleCall_4_0_1() { return cNameFeatureEAttributeQualifiedNameParserRuleCall_4_0_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}

	public class FeatureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Feature");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cEFeatureAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cEFeatureEStructuralFeatureCrossReference_0_0 = (CrossReference)cEFeatureAssignment_0.eContents().get(0);
		private final RuleCall cEFeatureEStructuralFeatureQualifiedNameParserRuleCall_0_0_1 = (RuleCall)cEFeatureEStructuralFeatureCrossReference_0_0.eContents().get(1);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueValueParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//Feature:
		//	eFeature=[ecore::EStructuralFeature|QualifiedName] ":" value=Value?;
		public ParserRule getRule() { return rule; }

		//eFeature=[ecore::EStructuralFeature|QualifiedName] ":" value=Value?
		public Group getGroup() { return cGroup; }

		//eFeature=[ecore::EStructuralFeature|QualifiedName]
		public Assignment getEFeatureAssignment_0() { return cEFeatureAssignment_0; }

		//[ecore::EStructuralFeature|QualifiedName]
		public CrossReference getEFeatureEStructuralFeatureCrossReference_0_0() { return cEFeatureEStructuralFeatureCrossReference_0_0; }

		//QualifiedName
		public RuleCall getEFeatureEStructuralFeatureQualifiedNameParserRuleCall_0_0_1() { return cEFeatureEStructuralFeatureQualifiedNameParserRuleCall_0_0_1; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//value=Value?
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//Value
		public RuleCall getValueValueParserRuleCall_2_0() { return cValueValueParserRuleCall_2_0; }
	}

	public class NewObjectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NewObject");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cEClassAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cEClassEClassCrossReference_0_0 = (CrossReference)cEClassAssignment_0.eContents().get(0);
		private final RuleCall cEClassEClassQualifiedNameParserRuleCall_0_0_1 = (RuleCall)cEClassEClassCrossReference_0_0.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameValidIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cFeaturesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cFeaturesFeatureParserRuleCall_3_0 = (RuleCall)cFeaturesAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// Re. use of QualifiedName, see SimplestWeiredNameTest (we want to permit EAttribute name to have dots; strange yes, but due to a particular requirement in an in-house closed source product)
		//// Also value isn't really optional semantically of course
		//// but because it may be missing while typing, this works out much better in practice like this
		//// the EFactoryJavaValidator flags it up if it's really missing
		//// without this, there are confusing parsing errors, the proposal provider doesn't work as it should, etc.
		//// Note that this is also in-lined below; if making changes, adapt below too
		//NewObject:
		//	eClass=[ecore::EClass|QualifiedName] name=ValidID? "{" features+=Feature* "}";
		public ParserRule getRule() { return rule; }

		//eClass=[ecore::EClass|QualifiedName] name=ValidID? "{" features+=Feature* "}"
		public Group getGroup() { return cGroup; }

		//eClass=[ecore::EClass|QualifiedName]
		public Assignment getEClassAssignment_0() { return cEClassAssignment_0; }

		//[ecore::EClass|QualifiedName]
		public CrossReference getEClassEClassCrossReference_0_0() { return cEClassEClassCrossReference_0_0; }

		//QualifiedName
		public RuleCall getEClassEClassQualifiedNameParserRuleCall_0_0_1() { return cEClassEClassQualifiedNameParserRuleCall_0_0_1; }

		//name=ValidID?
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ValidID
		public RuleCall getNameValidIDParserRuleCall_1_0() { return cNameValidIDParserRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//features+=Feature*
		public Assignment getFeaturesAssignment_3() { return cFeaturesAssignment_3; }

		//Feature
		public RuleCall getFeaturesFeatureParserRuleCall_3_0() { return cFeaturesFeatureParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Value");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cMultiValueParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAttributeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cGroup_2.eContents().get(0);
		private final Group cGroup_2_0_0 = (Group)cGroup_2_0.eContents().get(0);
		private final Action cNewObjectAction_2_0_0_0 = (Action)cGroup_2_0_0.eContents().get(0);
		private final Assignment cEClassAssignment_2_0_0_1 = (Assignment)cGroup_2_0_0.eContents().get(1);
		private final CrossReference cEClassEClassCrossReference_2_0_0_1_0 = (CrossReference)cEClassAssignment_2_0_0_1.eContents().get(0);
		private final RuleCall cEClassEClassQualifiedNameParserRuleCall_2_0_0_1_0_1 = (RuleCall)cEClassEClassCrossReference_2_0_0_1_0.eContents().get(1);
		private final Assignment cNameAssignment_2_0_0_2 = (Assignment)cGroup_2_0_0.eContents().get(2);
		private final RuleCall cNameValidIDParserRuleCall_2_0_0_2_0 = (RuleCall)cNameAssignment_2_0_0_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2_0_0_3 = (Keyword)cGroup_2_0_0.eContents().get(3);
		private final Assignment cFeaturesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cFeaturesFeatureParserRuleCall_2_1_0 = (RuleCall)cFeaturesAssignment_2_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Action cContainmentValueAction_2_3 = (Action)cGroup_2.eContents().get(3);
		private final RuleCall cReferenceParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Value:
		//	MultiValue // Following is an inlinedNewObject, if making changes, adapt above too
		//	// The Syntactic Predicate => is needed here to solve "Decision can match input such as "RULE_ID '.' RULE_ID {RULE_STRING..RULE_DATE, '}', '['..'false'}" using multiple alternatives: 3, 4"
		//	| Attribute | => ({NewObject} eClass=[ecore::EClass|QualifiedName] name=ValidID? "{") features+=Feature* "}"
		//	{Containment.value=current} | => Reference;
		public ParserRule getRule() { return rule; }

		//MultiValue // Following is an inlinedNewObject, if making changes, adapt above too
		//// The Syntactic Predicate => is needed here to solve "Decision can match input such as "RULE_ID '.' RULE_ID {RULE_STRING..RULE_DATE, '}', '['..'false'}" using multiple alternatives: 3, 4"
		//| Attribute | => ({NewObject} eClass=[ecore::EClass|QualifiedName] name=ValidID? "{") features+=Feature* "}"
		//{Containment.value=current} | => Reference
		public Alternatives getAlternatives() { return cAlternatives; }

		//MultiValue
		public RuleCall getMultiValueParserRuleCall_0() { return cMultiValueParserRuleCall_0; }

		//Attribute
		public RuleCall getAttributeParserRuleCall_1() { return cAttributeParserRuleCall_1; }

		//=> ({NewObject} eClass=[ecore::EClass|QualifiedName] name=ValidID? "{") features+=Feature* "}"
		//{Containment.value=current}
		public Group getGroup_2() { return cGroup_2; }

		//=> ({NewObject} eClass=[ecore::EClass|QualifiedName] name=ValidID? "{")
		public Group getGroup_2_0() { return cGroup_2_0; }

		//{NewObject} eClass=[ecore::EClass|QualifiedName] name=ValidID? "{"
		public Group getGroup_2_0_0() { return cGroup_2_0_0; }

		//{NewObject}
		public Action getNewObjectAction_2_0_0_0() { return cNewObjectAction_2_0_0_0; }

		//eClass=[ecore::EClass|QualifiedName]
		public Assignment getEClassAssignment_2_0_0_1() { return cEClassAssignment_2_0_0_1; }

		//[ecore::EClass|QualifiedName]
		public CrossReference getEClassEClassCrossReference_2_0_0_1_0() { return cEClassEClassCrossReference_2_0_0_1_0; }

		//QualifiedName
		public RuleCall getEClassEClassQualifiedNameParserRuleCall_2_0_0_1_0_1() { return cEClassEClassQualifiedNameParserRuleCall_2_0_0_1_0_1; }

		//name=ValidID?
		public Assignment getNameAssignment_2_0_0_2() { return cNameAssignment_2_0_0_2; }

		//ValidID
		public RuleCall getNameValidIDParserRuleCall_2_0_0_2_0() { return cNameValidIDParserRuleCall_2_0_0_2_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2_0_0_3() { return cLeftCurlyBracketKeyword_2_0_0_3; }

		//features+=Feature*
		public Assignment getFeaturesAssignment_2_1() { return cFeaturesAssignment_2_1; }

		//Feature
		public RuleCall getFeaturesFeatureParserRuleCall_2_1_0() { return cFeaturesFeatureParserRuleCall_2_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_2_2() { return cRightCurlyBracketKeyword_2_2; }

		//{Containment.value=current}
		public Action getContainmentValueAction_2_3() { return cContainmentValueAction_2_3; }

		//=> Reference
		public RuleCall getReferenceParserRuleCall_3() { return cReferenceParserRuleCall_3; }
	}

	public class MultiValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cMultiValueAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValuesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValuesValueParserRuleCall_2_0 = (RuleCall)cValuesAssignment_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//MultiValue:
		//	{MultiValue} "[" values+=Value* "]";
		public ParserRule getRule() { return rule; }

		//{MultiValue} "[" values+=Value* "]"
		public Group getGroup() { return cGroup; }

		//{MultiValue}
		public Action getMultiValueAction_0() { return cMultiValueAction_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }

		//values+=Value*
		public Assignment getValuesAssignment_2() { return cValuesAssignment_2; }

		//Value
		public RuleCall getValuesValueParserRuleCall_2_0() { return cValuesValueParserRuleCall_2_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}

	public class ReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Reference");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cValueEObjectCrossReference_0 = (CrossReference)cValueAssignment.eContents().get(0);
		private final RuleCall cValueEObjectQualifiedNameParserRuleCall_0_1 = (RuleCall)cValueEObjectCrossReference_0.eContents().get(1);
		
		//Reference: // NOTE we ref. an EObject, and not an [NewObject].. this EObject is always the
		//// respective "real" EObject, in the derived state if its a reference to something
		//// in an EFactory resource, or a reference to an existing non-EFactory EObject, 
		//// e.g. in an integration scenario with other Xtext grammars.
		//	value=[ecore::EObject|QualifiedName];
		public ParserRule getRule() { return rule; }

		//// NOTE we ref. an EObject, and not an [NewObject].. this EObject is always the
		//// respective "real" EObject, in the derived state if its a reference to something
		//// in an EFactory resource, or a reference to an existing non-EFactory EObject, 
		//// e.g. in an integration scenario with other Xtext grammars.
		//value=[ecore::EObject|QualifiedName]
		public Assignment getValueAssignment() { return cValueAssignment; }

		//[ecore::EObject|QualifiedName]
		public CrossReference getValueEObjectCrossReference_0() { return cValueEObjectCrossReference_0; }

		//QualifiedName
		public RuleCall getValueEObjectQualifiedNameParserRuleCall_0_1() { return cValueEObjectQualifiedNameParserRuleCall_0_1; }
	}

	public class AttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Attribute");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEnumAttributeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStringAttributeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIntegerAttributeParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cBooleanAttributeParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cDoubleAttributeParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cDateAttributeParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cNullAttributeParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		
		//Attribute:
		//	EnumAttribute | StringAttribute | IntegerAttribute | BooleanAttribute | DoubleAttribute | DateAttribute |
		//	NullAttribute;
		public ParserRule getRule() { return rule; }

		//EnumAttribute | StringAttribute | IntegerAttribute | BooleanAttribute | DoubleAttribute | DateAttribute | NullAttribute
		public Alternatives getAlternatives() { return cAlternatives; }

		//EnumAttribute
		public RuleCall getEnumAttributeParserRuleCall_0() { return cEnumAttributeParserRuleCall_0; }

		//StringAttribute
		public RuleCall getStringAttributeParserRuleCall_1() { return cStringAttributeParserRuleCall_1; }

		//IntegerAttribute
		public RuleCall getIntegerAttributeParserRuleCall_2() { return cIntegerAttributeParserRuleCall_2; }

		//BooleanAttribute
		public RuleCall getBooleanAttributeParserRuleCall_3() { return cBooleanAttributeParserRuleCall_3; }

		//DoubleAttribute
		public RuleCall getDoubleAttributeParserRuleCall_4() { return cDoubleAttributeParserRuleCall_4; }

		//DateAttribute
		public RuleCall getDateAttributeParserRuleCall_5() { return cDateAttributeParserRuleCall_5; }

		//NullAttribute
		public RuleCall getNullAttributeParserRuleCall_6() { return cNullAttributeParserRuleCall_6; }
	}

	public class EnumAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EnumAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cValueEEnumLiteralCrossReference_1_0 = (CrossReference)cValueAssignment_1.eContents().get(0);
		private final RuleCall cValueEEnumLiteralQualifiedNameParserRuleCall_1_0_1 = (RuleCall)cValueEEnumLiteralCrossReference_1_0.eContents().get(1);
		
		//EnumAttribute:
		//	":" value=[ecore::EEnumLiteral|QualifiedName];
		public ParserRule getRule() { return rule; }

		//":" value=[ecore::EEnumLiteral|QualifiedName]
		public Group getGroup() { return cGroup; }

		//":"
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }

		//value=[ecore::EEnumLiteral|QualifiedName]
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//[ecore::EEnumLiteral|QualifiedName]
		public CrossReference getValueEEnumLiteralCrossReference_1_0() { return cValueEEnumLiteralCrossReference_1_0; }

		//QualifiedName
		public RuleCall getValueEEnumLiteralQualifiedNameParserRuleCall_1_0_1() { return cValueEEnumLiteralQualifiedNameParserRuleCall_1_0_1; }
	}

	public class StringAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StringAttribute");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//// TODO Attribute Types should later not be hard-coded here anymore.. Grammar should be more open & generic.
		//StringAttribute:
		//	value=STRING;
		public ParserRule getRule() { return rule; }

		//value=STRING
		public Assignment getValueAssignment() { return cValueAssignment; }

		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_0() { return cValueSTRINGTerminalRuleCall_0; }
	}

	public class IntegerAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IntegerAttribute");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueLongParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//IntegerAttribute:
		//	value=Long;
		public ParserRule getRule() { return rule; }

		//value=Long
		public Assignment getValueAssignment() { return cValueAssignment; }

		//Long
		public RuleCall getValueLongParserRuleCall_0() { return cValueLongParserRuleCall_0; }
	}

	public class DoubleAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DoubleAttribute");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueDoubleParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//DoubleAttribute:
		//	value=Double;
		public ParserRule getRule() { return rule; }

		//value=Double
		public Assignment getValueAssignment() { return cValueAssignment; }

		//Double
		public RuleCall getValueDoubleParserRuleCall_0() { return cValueDoubleParserRuleCall_0; }
	}

	public class DateAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DateAttribute");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueDateParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//DateAttribute:
		//	value=Date;
		public ParserRule getRule() { return rule; }

		//value=Date
		public Assignment getValueAssignment() { return cValueAssignment; }

		//Date
		public RuleCall getValueDateParserRuleCall_0() { return cValueDateParserRuleCall_0; }
	}

	public class NullAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NullAttribute");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cValueNULLKeyword_0 = (Keyword)cValueAssignment.eContents().get(0);
		
		//NullAttribute:
		//	value="NULL";
		public ParserRule getRule() { return rule; }

		//value="NULL"
		public Assignment getValueAssignment() { return cValueAssignment; }

		//"NULL"
		public Keyword getValueNULLKeyword_0() { return cValueNULLKeyword_0; }
	}

	public class BooleanAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanAttribute");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueBooleanParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//BooleanAttribute:
		//	value=Boolean;
		public ParserRule getRule() { return rule; }

		//value=Boolean
		public Assignment getValueAssignment() { return cValueAssignment; }

		//Boolean
		public RuleCall getValueBooleanParserRuleCall_0() { return cValueBooleanParserRuleCall_0; }
	}

	public class QualifiedNameWithWildcardElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualifiedNameWithWildcard");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cQualifiedNameParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopAsteriskKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//QualifiedNameWithWildcard:
		//	QualifiedName ".*"?;
		public ParserRule getRule() { return rule; }

		//QualifiedName ".*"?
		public Group getGroup() { return cGroup; }

		//QualifiedName
		public RuleCall getQualifiedNameParserRuleCall_0() { return cQualifiedNameParserRuleCall_0; }

		//".*"?
		public Keyword getFullStopAsteriskKeyword_1() { return cFullStopAsteriskKeyword_1; }
	}

	public class QualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualifiedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cValidIDParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cValidIDParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//QualifiedName:
		//	ValidID ("." ValidID)*;
		public ParserRule getRule() { return rule; }

		//ValidID ("." ValidID)*
		public Group getGroup() { return cGroup; }

		//ValidID
		public RuleCall getValidIDParserRuleCall_0() { return cValidIDParserRuleCall_0; }

		//(=> "." ValidID)*
		public Group getGroup_1() { return cGroup_1; }

		//=> "."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//ValidID
		public RuleCall getValidIDParserRuleCall_1_1() { return cValidIDParserRuleCall_1_1; }
	}

	public class ValidIDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ValidID");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLONG_IDTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cLONG_UNSIGNEDTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// This is needed so that IDs consisting only of digit/numbers work, including in QualifiedName (DS-8268).
		//ValidID:
		//	ID | LONG_ID | LONG_UNSIGNED;
		public ParserRule getRule() { return rule; }

		//ID | LONG_ID | LONG_UNSIGNED
		public Alternatives getAlternatives() { return cAlternatives; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//LONG_ID
		public RuleCall getLONG_IDTerminalRuleCall_1() { return cLONG_IDTerminalRuleCall_1; }

		//LONG_UNSIGNED
		public RuleCall getLONG_UNSIGNEDTerminalRuleCall_2() { return cLONG_UNSIGNEDTerminalRuleCall_2; }
	}

	public class BooleanElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Boolean");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTrueKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//// Double and Date are Xtext data types instead of terminals, because if they are terminals there is some confusion about the '.' in them vs. the QualifiedName dot in case a QualifiedName has parts consisting only of numbers  
		//Boolean returns ecore::EBoolean:
		//	"true" | "false";
		public ParserRule getRule() { return rule; }

		//"true" | "false"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"true"
		public Keyword getTrueKeyword_0() { return cTrueKeyword_0; }

		//"false"
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }
	}

	public class LongElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Long");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cLONG_UNSIGNEDTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Long returns ecore::ELong:
		//	"-"? LONG_UNSIGNED;
		public ParserRule getRule() { return rule; }

		//"-"? LONG_UNSIGNED
		public Group getGroup() { return cGroup; }

		//"-"?
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }

		//LONG_UNSIGNED
		public RuleCall getLONG_UNSIGNEDTerminalRuleCall_1() { return cLONG_UNSIGNEDTerminalRuleCall_1; }
	}

	public class DoubleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Double");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLongParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cLONG_UNSIGNEDTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//Double returns ecore::EDouble:
		//	Long "." LONG_UNSIGNED;
		public ParserRule getRule() { return rule; }

		//Long "." LONG_UNSIGNED
		public Group getGroup() { return cGroup; }

		//Long
		public RuleCall getLongParserRuleCall_0() { return cLongParserRuleCall_0; }

		//"."
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }

		//LONG_UNSIGNED
		public RuleCall getLONG_UNSIGNEDTerminalRuleCall_2() { return cLONG_UNSIGNEDTerminalRuleCall_2; }
	}

	public class DateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Date");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLONG_UNSIGNEDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cLONG_UNSIGNEDTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cFullStopKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final RuleCall cLONG_UNSIGNEDTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//Date returns ecore::EDate:
		//	LONG_UNSIGNED "." LONG_UNSIGNED "." LONG_UNSIGNED;
		public ParserRule getRule() { return rule; }

		//LONG_UNSIGNED "." LONG_UNSIGNED "." LONG_UNSIGNED
		public Group getGroup() { return cGroup; }

		//LONG_UNSIGNED
		public RuleCall getLONG_UNSIGNEDTerminalRuleCall_0() { return cLONG_UNSIGNEDTerminalRuleCall_0; }

		//"."
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }

		//LONG_UNSIGNED
		public RuleCall getLONG_UNSIGNEDTerminalRuleCall_2() { return cLONG_UNSIGNEDTerminalRuleCall_2; }

		//"."
		public Keyword getFullStopKeyword_3() { return cFullStopKeyword_3; }

		//LONG_UNSIGNED
		public RuleCall getLONG_UNSIGNEDTerminalRuleCall_4() { return cLONG_UNSIGNEDTerminalRuleCall_4; }
	}
	
	
	private FactoryElements pFactory;
	private PackageImportElements pPackageImport;
	private NamespaceImportElements pNamespaceImport;
	private AnnotationElements pAnnotation;
	private CustomNameMappingElements pCustomNameMapping;
	private FeatureElements pFeature;
	private NewObjectElements pNewObject;
	private ValueElements pValue;
	private MultiValueElements pMultiValue;
	private ReferenceElements pReference;
	private AttributeElements pAttribute;
	private EnumAttributeElements pEnumAttribute;
	private StringAttributeElements pStringAttribute;
	private IntegerAttributeElements pIntegerAttribute;
	private DoubleAttributeElements pDoubleAttribute;
	private DateAttributeElements pDateAttribute;
	private NullAttributeElements pNullAttribute;
	private BooleanAttributeElements pBooleanAttribute;
	private QualifiedNameWithWildcardElements pQualifiedNameWithWildcard;
	private QualifiedNameElements pQualifiedName;
	private ValidIDElements pValidID;
	private BooleanElements pBoolean;
	private LongElements pLong;
	private DoubleElements pDouble;
	private DateElements pDate;
	private TerminalRule tLONG_ID;
	private TerminalRule tLONG_UNSIGNED;
	private TerminalRule tID;
	
	private final Grammar grammar;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public EFactoryGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.eclipse.emf.eson.EFactory".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Factory:
	//	imports+=NamespaceImport* epackages+=PackageImport* annotations+=Annotation* root=NewObject;
	public FactoryElements getFactoryAccess() {
		return (pFactory != null) ? pFactory : (pFactory = new FactoryElements());
	}
	
	public ParserRule getFactoryRule() {
		return getFactoryAccess().getRule();
	}

	//PackageImport: // TODO Validation rule with "deprecated" warning for 'use', now that we have 'import' instead 
	//	"use" ePackage=[ecore::EPackage|QualifiedName] ".*";
	public PackageImportElements getPackageImportAccess() {
		return (pPackageImport != null) ? pPackageImport : (pPackageImport = new PackageImportElements());
	}
	
	public ParserRule getPackageImportRule() {
		return getPackageImportAccess().getRule();
	}

	//// TODO like the *.Xtext grammar itself does, support namespace and package name based (try the 'import' above!) + maybe support an "as" syntax
	//// TODO Content Assist for EPackage .. but one COULD also import other named NewObject / EObject, instead of EPackages.. hm. As EPackage will be much more common, just support that.	
	//NamespaceImport:
	//	"import" importedNamespace=QualifiedNameWithWildcard;
	public NamespaceImportElements getNamespaceImportAccess() {
		return (pNamespaceImport != null) ? pNamespaceImport : (pNamespaceImport = new NamespaceImportElements());
	}
	
	public ParserRule getNamespaceImportRule() {
		return getNamespaceImportAccess().getRule();
	}

	//Annotation:
	//	CustomNameMapping;
	public AnnotationElements getAnnotationAccess() {
		return (pAnnotation != null) ? pAnnotation : (pAnnotation = new AnnotationElements());
	}
	
	public ParserRule getAnnotationRule() {
		return getAnnotationAccess().getRule();
	}

	//// TODO further consider if name mapping is best put in-line into objects.. it would have to repeat in every file..
	//// logically this rather belongs into an external mapping, like HUTN's Configuration (HutnConfig), or even better directly into an Xcore as annotations 
	//CustomNameMapping:
	//	"@Name" "{" eClass=[ecore::EClass|QualifiedName] "=" nameFeature=[ecore::EAttribute|QualifiedName] "}";
	public CustomNameMappingElements getCustomNameMappingAccess() {
		return (pCustomNameMapping != null) ? pCustomNameMapping : (pCustomNameMapping = new CustomNameMappingElements());
	}
	
	public ParserRule getCustomNameMappingRule() {
		return getCustomNameMappingAccess().getRule();
	}

	//Feature:
	//	eFeature=[ecore::EStructuralFeature|QualifiedName] ":" value=Value?;
	public FeatureElements getFeatureAccess() {
		return (pFeature != null) ? pFeature : (pFeature = new FeatureElements());
	}
	
	public ParserRule getFeatureRule() {
		return getFeatureAccess().getRule();
	}

	//// Re. use of QualifiedName, see SimplestWeiredNameTest (we want to permit EAttribute name to have dots; strange yes, but due to a particular requirement in an in-house closed source product)
	//// Also value isn't really optional semantically of course
	//// but because it may be missing while typing, this works out much better in practice like this
	//// the EFactoryJavaValidator flags it up if it's really missing
	//// without this, there are confusing parsing errors, the proposal provider doesn't work as it should, etc.
	//// Note that this is also in-lined below; if making changes, adapt below too
	//NewObject:
	//	eClass=[ecore::EClass|QualifiedName] name=ValidID? "{" features+=Feature* "}";
	public NewObjectElements getNewObjectAccess() {
		return (pNewObject != null) ? pNewObject : (pNewObject = new NewObjectElements());
	}
	
	public ParserRule getNewObjectRule() {
		return getNewObjectAccess().getRule();
	}

	//Value:
	//	MultiValue // Following is an inlinedNewObject, if making changes, adapt above too
	//	// The Syntactic Predicate => is needed here to solve "Decision can match input such as "RULE_ID '.' RULE_ID {RULE_STRING..RULE_DATE, '}', '['..'false'}" using multiple alternatives: 3, 4"
	//	| Attribute | => ({NewObject} eClass=[ecore::EClass|QualifiedName] name=ValidID? "{") features+=Feature* "}"
	//	{Containment.value=current} | => Reference;
	public ValueElements getValueAccess() {
		return (pValue != null) ? pValue : (pValue = new ValueElements());
	}
	
	public ParserRule getValueRule() {
		return getValueAccess().getRule();
	}

	//MultiValue:
	//	{MultiValue} "[" values+=Value* "]";
	public MultiValueElements getMultiValueAccess() {
		return (pMultiValue != null) ? pMultiValue : (pMultiValue = new MultiValueElements());
	}
	
	public ParserRule getMultiValueRule() {
		return getMultiValueAccess().getRule();
	}

	//Reference: // NOTE we ref. an EObject, and not an [NewObject].. this EObject is always the
	//// respective "real" EObject, in the derived state if its a reference to something
	//// in an EFactory resource, or a reference to an existing non-EFactory EObject, 
	//// e.g. in an integration scenario with other Xtext grammars.
	//	value=[ecore::EObject|QualifiedName];
	public ReferenceElements getReferenceAccess() {
		return (pReference != null) ? pReference : (pReference = new ReferenceElements());
	}
	
	public ParserRule getReferenceRule() {
		return getReferenceAccess().getRule();
	}

	//Attribute:
	//	EnumAttribute | StringAttribute | IntegerAttribute | BooleanAttribute | DoubleAttribute | DateAttribute |
	//	NullAttribute;
	public AttributeElements getAttributeAccess() {
		return (pAttribute != null) ? pAttribute : (pAttribute = new AttributeElements());
	}
	
	public ParserRule getAttributeRule() {
		return getAttributeAccess().getRule();
	}

	//EnumAttribute:
	//	":" value=[ecore::EEnumLiteral|QualifiedName];
	public EnumAttributeElements getEnumAttributeAccess() {
		return (pEnumAttribute != null) ? pEnumAttribute : (pEnumAttribute = new EnumAttributeElements());
	}
	
	public ParserRule getEnumAttributeRule() {
		return getEnumAttributeAccess().getRule();
	}

	//// TODO Attribute Types should later not be hard-coded here anymore.. Grammar should be more open & generic.
	//StringAttribute:
	//	value=STRING;
	public StringAttributeElements getStringAttributeAccess() {
		return (pStringAttribute != null) ? pStringAttribute : (pStringAttribute = new StringAttributeElements());
	}
	
	public ParserRule getStringAttributeRule() {
		return getStringAttributeAccess().getRule();
	}

	//IntegerAttribute:
	//	value=Long;
	public IntegerAttributeElements getIntegerAttributeAccess() {
		return (pIntegerAttribute != null) ? pIntegerAttribute : (pIntegerAttribute = new IntegerAttributeElements());
	}
	
	public ParserRule getIntegerAttributeRule() {
		return getIntegerAttributeAccess().getRule();
	}

	//DoubleAttribute:
	//	value=Double;
	public DoubleAttributeElements getDoubleAttributeAccess() {
		return (pDoubleAttribute != null) ? pDoubleAttribute : (pDoubleAttribute = new DoubleAttributeElements());
	}
	
	public ParserRule getDoubleAttributeRule() {
		return getDoubleAttributeAccess().getRule();
	}

	//DateAttribute:
	//	value=Date;
	public DateAttributeElements getDateAttributeAccess() {
		return (pDateAttribute != null) ? pDateAttribute : (pDateAttribute = new DateAttributeElements());
	}
	
	public ParserRule getDateAttributeRule() {
		return getDateAttributeAccess().getRule();
	}

	//NullAttribute:
	//	value="NULL";
	public NullAttributeElements getNullAttributeAccess() {
		return (pNullAttribute != null) ? pNullAttribute : (pNullAttribute = new NullAttributeElements());
	}
	
	public ParserRule getNullAttributeRule() {
		return getNullAttributeAccess().getRule();
	}

	//BooleanAttribute:
	//	value=Boolean;
	public BooleanAttributeElements getBooleanAttributeAccess() {
		return (pBooleanAttribute != null) ? pBooleanAttribute : (pBooleanAttribute = new BooleanAttributeElements());
	}
	
	public ParserRule getBooleanAttributeRule() {
		return getBooleanAttributeAccess().getRule();
	}

	//QualifiedNameWithWildcard:
	//	QualifiedName ".*"?;
	public QualifiedNameWithWildcardElements getQualifiedNameWithWildcardAccess() {
		return (pQualifiedNameWithWildcard != null) ? pQualifiedNameWithWildcard : (pQualifiedNameWithWildcard = new QualifiedNameWithWildcardElements());
	}
	
	public ParserRule getQualifiedNameWithWildcardRule() {
		return getQualifiedNameWithWildcardAccess().getRule();
	}

	//QualifiedName:
	//	ValidID ("." ValidID)*;
	public QualifiedNameElements getQualifiedNameAccess() {
		return (pQualifiedName != null) ? pQualifiedName : (pQualifiedName = new QualifiedNameElements());
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}

	//// This is needed so that IDs consisting only of digit/numbers work, including in QualifiedName (DS-8268).
	//ValidID:
	//	ID | LONG_ID | LONG_UNSIGNED;
	public ValidIDElements getValidIDAccess() {
		return (pValidID != null) ? pValidID : (pValidID = new ValidIDElements());
	}
	
	public ParserRule getValidIDRule() {
		return getValidIDAccess().getRule();
	}

	//// Double and Date are Xtext data types instead of terminals, because if they are terminals there is some confusion about the '.' in them vs. the QualifiedName dot in case a QualifiedName has parts consisting only of numbers  
	//Boolean returns ecore::EBoolean:
	//	"true" | "false";
	public BooleanElements getBooleanAccess() {
		return (pBoolean != null) ? pBoolean : (pBoolean = new BooleanElements());
	}
	
	public ParserRule getBooleanRule() {
		return getBooleanAccess().getRule();
	}

	//Long returns ecore::ELong:
	//	"-"? LONG_UNSIGNED;
	public LongElements getLongAccess() {
		return (pLong != null) ? pLong : (pLong = new LongElements());
	}
	
	public ParserRule getLongRule() {
		return getLongAccess().getRule();
	}

	//Double returns ecore::EDouble:
	//	Long "." LONG_UNSIGNED;
	public DoubleElements getDoubleAccess() {
		return (pDouble != null) ? pDouble : (pDouble = new DoubleElements());
	}
	
	public ParserRule getDoubleRule() {
		return getDoubleAccess().getRule();
	}

	//Date returns ecore::EDate:
	//	LONG_UNSIGNED "." LONG_UNSIGNED "." LONG_UNSIGNED;
	public DateElements getDateAccess() {
		return (pDate != null) ? pDate : (pDate = new DateElements());
	}
	
	public ParserRule getDateRule() {
		return getDateAccess().getRule();
	}

	//// TODO Date and other attribute values syntax should later not be hard-coded here anymore at all.. Grammar should be more open & generic.
	//terminal LONG_ID:
	//	LONG_UNSIGNED ID;
	public TerminalRule getLONG_IDRule() {
		return (tLONG_ID != null) ? tLONG_ID : (tLONG_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LONG_ID"));
	} 

	//terminal LONG_UNSIGNED returns ecore::ELong:
	//	"0".."9"+;
	public TerminalRule getLONG_UNSIGNEDRule() {
		return (tLONG_UNSIGNED != null) ? tLONG_UNSIGNED : (tLONG_UNSIGNED = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LONG_UNSIGNED"));
	} 

	//// Due to historic reasons in a closed source an in-house product which uses ESON
	//// we need to add ',' and '-' to be allowed in IDs.  We also permit ID starting with digits, via the ValidID: ID | LONG above.
	//// (NOTE: This terminal must be named 'ID' as well, not some new ID2 - unless you write a new ValueConverter for it.)
	//// PS: Order of terminals appears to matter - ID needs to come last (at least it used to matter; perhaps no longer after grammar changes which made attribute value data type rules instead of terminals)
	//// TODO copy/paste org.eclipse.xtext.common.Terminals 
	////terminal STRING	: 
	////			'"' ( '\\' . / * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !('\\'|'"') )* '"' |
	////			"'" ( '\\' . / * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !('\\'|"'") )* "'" ; 
	////terminal ML_COMMENT	: '/ *' -> '* /';
	////terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;
	////
	////terminal WS			: (' '|'\t'|'\r'|'\n')+;
	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_" | "," | "-") ("a".."z" | "A".."Z" | "_" | "," | "-" | "0".."9")*;
	public TerminalRule getIDRule() {
		return (tID != null) ? tID : (tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ID"));
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
